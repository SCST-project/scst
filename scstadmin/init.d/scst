#!/bin/sh
#
# Copyright (C) 2008 Mark Buechler <mark.buechler@gmail.com>
# Copyright (C) 2009-2011 Bart Van Assche <bvanassche@acm.org>
# This software is made available under the GPLv2 license.
#
# System startup script for SCST.
#
# See also:
# * http://refspecs.freestandards.org/LSB_4.1.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html
# * http://www.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
#
### BEGIN INIT INFO
# Provides:       scst
# Required-Start: $syslog $local_fs $network
# Required-Stop:  $syslog $local_fs $network
# Default-Start:  2 3 4 5
# Default-Stop:   0 1 6
# Description:    SCST - A Generic SCSI Target Subsystem
### END INIT INFO
### BEGIN CHKCONFIG INFO
# chkconfig:      2345 13 87
# description:    SCST - A Generic SCSI Target Subsystem
### END CHKCONFIG INFO

# Return values according to LSB for all commands except status:
# 0 - success
# 1 - generic or unspecified error
# 2 - invalid or excess argument(s)
# 3 - unimplemented feature (e.g. "reload")
# 4 - insufficient privilege
# 5 - program is not installed
# 6 - program is not configured
# 7 - program is not running
#

if [ -e /lib/lsb/init-functions ]; then
    # Debian, RHEL / Fedora, SLES / openSUSE.
    . /lib/lsb/init-functions
else
# Slackware / Gentoo.
start_daemon() {
    "$@" >/dev/null 2>&1 &
}
killproc() {
    local exe="`basename "$1"`"
    killall $exe
    rm -f "/var/run/$exe.pid"
}
log_success_msg() {
    echo "$@"
}
log_failure_msg() {
    echo "$@"
}
fi

PATH=/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/sbin:/usr/local/bin
SCST_CFG=/etc/scst.conf
SCST_DFLT=/etc/default/scst

[ -x "$(which scstadmin)" ] || exit 5

if [ -f $SCST_DFLT ]; then
    . $SCST_DFLT
fi

# Whether or not there is a "TARGET_DRIVER iscsi" section in scst.conf.
using_iscsi() {
    for m in $SCST_MODULES; do
        if [ $m = "iscsi_scst" ]; then
            return 0
        fi
    done
    return 1
}

# Parse scst.conf and assign the list of associated kernel modules to
# SCST_MODULES.
parse_scst_conf() {
    if [ ! -e $SCST_CFG ]; then
        return 1
    fi
    local nonblanks="[^ 	]\{1,\}"
    local blanks="[ 	]\{1,\}"
    SCST_MODULES="scst `sed -n -e 's/^HANDLER'"$blanks"'\('"$nonblanks"'\)'"$blanks"'{$/\1/p' \
                         -e 's/^\[HANDLER'"$blanks"'\('"$nonblanks"'\)\]$/\1/p' $SCST_CFG \
        | while read h; do
            case "$h" in
                dev_cdrom)      echo scst_cdrom;;
                dev_changer)    echo scst_changer;;
                dev_disk*)      echo scst_disk;;
                dev_modisk*)    echo scst_modisk;;
                dev_processor)  echo scst_processor;;
                dev_raid)       echo scst_raid;;
                dev_tape*)      echo scst_tape;;
                dev_user)       echo scst_user;;
                vdisk*|vcdrom)  echo scst_vdisk;;
                *)              echo "$h";;
            esac
        done | sort -u` \
        `sed -n 's/^TARGET_DRIVER'"$blanks"'\('"$nonblanks"'\)'"$blanks"'{$/\1/p' $SCST_CFG | while read d; do
            case "$d" in
                iscsi)    echo iscsi_scst;;
                qla2x00t) echo qla2x00tgt;;
                *)        echo "$d";;
            esac
        done | sort -u` \
        $SCST_TARGET_MODULES"
    if using_iscsi; then
        case "`uname -m`" in
            x86_64|i686)
                SCST_OPT_MODULES="crc32c-intel $SCST_OPT_MODULES";;
        esac
        SCST_OPT_MODULES="crc32c $SCST_OPT_MODULES"
        SCST_DAEMONS="/usr/local/sbin/iscsi-scstd $SCST_DAEMONS"
    fi
}

# Stop SCST. parse_scst_conf must already have been invoked.
stop() {
    for d in $SCST_DAEMONS; do
        killproc $d
    done

    reverse_list=""
    for m in $SCST_MODULES; do
        reverse_list="$m $reverse_list"
    done
    for m in $reverse_list; do
        refcnt="`cat /sys/module/$m/refcnt 2>/dev/null`"
        if [ ! -z "$refcnt" ] && [ "$refcnt" -gt 0 ]; then
            # Apparently it can happen that the iscsi_scst refcnt is only
            # decremented a short time after killproc finished. If that
            # occurs, sleep for a short time.
            sleep 1
        fi
        if [ -e /sys/module/$m/refcnt ] && ! rmmod $m; then
            return 1
        fi
    done
    for m in $SCST_OPT_MODULES; do
        reverse_list="$m $reverse_list"
    done
    for m in $reverse_list; do
        rmmod $m >/dev/null 2>&1
    done

    # Clear the config in case unloading failed or SCST has been built into the
    # kernel
    if [ -e /sys/module/scst ]; then
        echo y | scstadmin -clear_config -force >/dev/null 2>&1
    fi

    return 0
}

case "$1" in
    start)
        ## Start the service.
        echo -n "Loading and configuring SCST"

        if [ -e /sys/module/scst -a -e /sys/module/scst/refcnt ]; then
            log_failure_msg
            echo Already started
            exit 1
        fi

        parse_scst_conf

        for m in $SCST_OPT_MODULES; do
            modprobe $m >/dev/null 2>&1
        done

        for m in $SCST_MODULES; do
            module_params="`set | sed -n -e "s/^${m}_parameters='\(.*\)'$/\1/p"\
                                         -e "s/^${m}_parameters=\(.*\)$/\1/p"`"
            if [ ! -e /sys/module/$m ]; then
                if ! modprobe $m $module_params; then
                    log_failure_msg
                    echo modprobe $m $module_params failed.
                    stop
                    exit 5
                fi
            else
                for pv in $module_params; do
                    echo $pv | sed 's/=/ /' \
                      | { read param value;
                           echo "$value" >/sys/module/$m/parameters/$param; }
                done
            fi
        done

        for d in $SCST_DAEMONS; do
            if ! start_daemon $d; then
                log_failure_msg
                echo "Starting $d failed"
                stop
                exit 1
            fi
        done

        if [ -f $SCST_CFG ]; then
            echo y | scstadmin -clear_config -force >/dev/null 2>&1
            tmpout=/tmp/scstadmin-output-$$
            if scstadmin -config $SCST_CFG >$tmpout 2>&1; then
                rm -f $tmpout
       	        log_success_msg
            else
                log_failure_msg
                cat $tmpout
                rm -f $tmpout
                stop
                exit 1
            fi
        else
            log_success_msg
            echo "SCST configuration file $SCST_CFG missing"
        fi
        ;;
    stop)
        ## Stop the service.
        echo -n "Stopping SCST"

        if ! parse_scst_conf; then
            log_failure_msg "No $SCST_CFG found"
            exit 1
        fi

        stop

        rc=$?
        if [ $rc = 0 ]; then
            log_success_msg
        else
            log_failure_msg
        fi
        exit $rc
        ;;
    restart)
        ## Stop and restart the service if the service is already running,
        ## otherwise start the service.
        if $0 stop; then
            $0 start
        fi
        ;;
    try-restart)
        ## Restart the service if the service is already running.
        $0 status >/dev/null 2>&1 && $0 restart
        ;;
    reload)
        ## Cause the configuration of the service to be reloaded without
        ## actually stopping and restarting the service.
        echo -n "Reloading SCST configuration"
        if scstadmin -config $SCST_CFG >/dev/null 2>&1; then
            log_success_msg
        else
            log_failure_msg
            exit 1
        fi
        ;;
    force-reload)
        ## Cause the configuration to be reloaded if the service supports this,
        ## otherwise restart the service if it is running.
        echo -n "Reloading SCST configuration"
        if scstadmin -config $SCST_CFG >/dev/null 2>&1; then
            log_success_msg
        else
            $0 restart
        fi
        ;;
    status)
        ## Print the current status of the service.
        echo -n "SCST status: "

        # Status has a slightly different meaning for the status command:
        # 0 - service running
        # 1 - service dead, but /var/run/  pid  file exists
        # 2 - service dead, but /var/lock/ lock file exists
        # 3 - service not running

        parse_scst_conf

        for m in $SCST_MODULES; do
            if [ ! -e /sys/module/$m ]; then
                echo "$m: not loaded"
                exit 3
            fi
        done
        echo "OK"
        ;;
    *)
        echo "Usage: $0 {start|stop|status|try-restart|restart|force-reload|reload}"
        exit 2
        ;;
esac

exit 0
